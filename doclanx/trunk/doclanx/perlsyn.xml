<?xml version='1.0' ?>
<!-- <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oa
sis-open.org/docbook/xml/4.1.2/docbookx.dtd"[]> -->
<!-- This comment is meant to settle gvim -->
<!--
     Generated by Pod::DocBook v1.2, using:
       Digest::MD5 v2.33
       Pod::Parser v1.14
       Pod::ParseLink v1.06
       Text::ParseWords v3.21
       Text::Wrap v2001.09291
-->
<chapter>
<title>Perl Syntax</title>
<para>
A Perl program consists of a sequence of declarations and statements which
run from the top to the bottom.  Loops, subroutines and other control
structures allow you to jump around within the code.
</para>
<para>
Perl is a <emphasis role="bold">free-form</emphasis> language, you can
format and indent it however you like.	Whitespace mostly serves to
separate tokens, unlike languages like Python where it is an important part
of the syntax.
</para>
<para>
Many of Perl's syntactic elements are <emphasis
role="bold">optional</emphasis>.  Rather than requiring you to put
parentheses around every function call and declare every variable, you can
often leave such explicit elements off and Perl will figure out what you
meant.	This is known as <emphasis role="bold">Do What I Mean</emphasis>,
abbreviated <emphasis role="bold">DWIM</emphasis>.  It allows programmers
to be <emphasis role="bold">lazy</emphasis> and to code in a style with
which they are comfortable.
</para>
<para>
Perl <emphasis role="bold">borrows syntax</emphasis> and concepts from many
languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. 
Other languages have borrowed syntax from Perl, particularly its regular
expression extensions.	So if you have programmed in another language you
will see familiar pieces in Perl.  They often work the same, but see
<citerefentry> <refentrytitle>perltrap</refentrytitle> </citerefentry> for
information about how they differ.
</para>
<section id="ID-b8981918d95cce4ba97f9cee97e0bb3f"><title>Declarations</title>
<para>
The only things you need to declare in Perl are report formats and
subroutines (and sometimes not even subroutines).  A variable holds the
undefined value (<literal role="code"><![CDATA[undef]]></literal>) until it
has been assigned a defined value, which is anything other than <literal
role="code"><![CDATA[undef]]></literal>.  When used as a number, <literal
role="code"><![CDATA[undef]]></literal> is treated as <literal
role="code"><![CDATA[0]]></literal>; when used as a string, it is treated
as the empty string, <literal role="code"><![CDATA[""]]></literal>; and
when used as a reference that isn't being assigned to, it is treated as an
error.	If you enable warnings, you'll be notified of an uninitialized
value whenever you treat <literal role="code"><![CDATA[undef]]></literal>
as a string or a number.  Well, usually.  Boolean contexts, such as:
</para>
<screen><![CDATA[my $a;
if ($a) {}]]></screen>
<para>
are exempt from warnings (because they care about truth rather than
definedness).  Operators such as <literal
role="code"><![CDATA[++]]></literal>, <literal
role="code"><![CDATA[--]]></literal>, <literal
role="code"><![CDATA[+=]]></literal>, <literal
role="code"><![CDATA[-=]]></literal>, and <literal
role="code"><![CDATA[.=]]></literal>, that operate on undefined left values
such as:
</para>
<screen><![CDATA[my $a;
$a++;]]></screen>
<para>
are also always exempt from such warnings.
</para>
<para>
A declaration can be put anywhere a statement can, but has no effect on the
execution of the primary sequence of statements--declarations all take
effect at compile time.  Typically all the declarations are put at the
beginning or the end of the script.  However, if you're using
lexically-scoped private variables created with <literal
role="code"><![CDATA[my()]]></literal>, you'll have to make sure your
format or subroutine definition is within the same block scope as the my if
you expect to be able to access those private variables.
</para>
<para>
Declaring a subroutine allows a subroutine name to be used as if it were a
list operator from that point forward in the program.  You can declare a
subroutine without defining it by saying <literal role="code"><![CDATA[sub
name]]></literal>, thus:
</para>
<screen><![CDATA[sub myname;
$me = myname $0             or die "can't get myname";]]></screen>
<para>
Note that myname() functions as a list operator, not as a unary operator;
so be careful to use <literal role="code"><![CDATA[or]]></literal> instead
of <literal role="code"><![CDATA[||]]></literal> in this case.	However, if
you were to declare the subroutine as <literal role="code"><![CDATA[sub
myname ($)]]></literal>, then <literal
role="code"><![CDATA[myname]]></literal> would function as a unary
operator, so either <literal role="code"><![CDATA[or]]></literal> or
<literal role="code"><![CDATA[||]]></literal> would work.
</para>
<para>
Subroutines declarations can also be loaded up with the <literal
role="code"><![CDATA[require]]></literal> statement or both loaded and
imported into your namespace with a <literal
role="code"><![CDATA[use]]></literal> statement. See <citerefentry>
<refentrytitle>perlmod</refentrytitle> </citerefentry> for details on this.
</para>
<para>
A statement sequence may contain declarations of lexically-scoped
variables, but apart from declaring a variable name, the declaration acts
like an ordinary statement, and is elaborated within the sequence of
statements as if it were an ordinary statement.  That means it actually has
both compile-time and run-time effects.
</para>
</section>
<section id="ID-5094f3082d0c6ac9208c4d561c3b1c8b"><title>Comments</title>
<para>
Text from a <literal role="code"><![CDATA["#"]]></literal> character until
the end of the line is a comment, and is ignored.  Exceptions include
<literal role="code"><![CDATA["#"]]></literal> inside a string or regular
expression.
</para>
</section>
<section id="ID-a14fbc02e2a4786abe44132a0e1501f0"><title>Simple Statements</title>
<para>
The only kind of simple statement is an expression evaluated for its side
effects.  Every simple statement must be terminated with a semicolon,
unless it is the final statement in a block, in which case the semicolon is
optional.  (A semicolon is still encouraged if the block takes up more than
one line, because you may eventually add another line.)  Note that there
are some operators like <literal role="code"><![CDATA[eval {}]]></literal>
and <literal role="code"><![CDATA[do {}]]></literal> that look like
compound statements, but aren't (they're just TERMs in an expression), and
thus need an explicit termination if used as the last item in a statement.
</para>
</section>
<section id="ID-1e3779cadd22c3bbc0041c91368a8278"><title>Truth and Falsehood</title>
<para>
The number 0, the strings <literal role="code"><![CDATA['0']]></literal>
and <literal role="code"><![CDATA['']]></literal>, the empty list <literal
role="code"><![CDATA[()]]></literal>, and <literal
role="code"><![CDATA[undef]]></literal> are all false in a boolean context.
All other values are true.
</para>
</section>
<section id="ID-64fb5ae3ed8e1c09da1bea3b23b27739"><title>Statement Modifiers</title>
<para>
Any simple statement may optionally be followed by a <emphasis
role="italic">SINGLE</emphasis> modifier, just before the terminating
semicolon (or block ending).  The possible modifiers are:
</para>
<screen><![CDATA[if EXPR
unless EXPR
while EXPR
until EXPR
foreach LIST]]></screen>
<para>
The <literal role="code"><![CDATA[EXPR]]></literal> following the modifier
is referred to as the "condition". Its truth or falsehood determines how
the modifier will behave.
</para>
<para>
<literal role="code"><![CDATA[if]]></literal> executes the statement once
<emphasis role="italic">if</emphasis> and only if the condition is true. 
<literal role="code"><![CDATA[unless]]></literal> is the opposite, it
executes the statement <emphasis role="italic">unless</emphasis> the
condition is true (i.e., if the condition is false).
</para>
<screen><![CDATA[print "Basset hounds got long ears" if length $ear >= 10;
go_outside() and play() unless $is_raining;]]></screen>
<para>
The <literal role="code"><![CDATA[foreach]]></literal> modifier is an
iterator: it executes the statement once for each item in the LIST (with
<literal role="code"><![CDATA[$_]]></literal> aliased to each item in
turn).
</para>
<screen><![CDATA[print "Hello $_!\n" foreach qw(world Dolly nurse);]]></screen>
<para>
<literal role="code"><![CDATA[while]]></literal> repeats the statement
<emphasis role="italic">while</emphasis> the condition is true. <literal
role="code"><![CDATA[until]]></literal> does the opposite, it repeats the
statement <emphasis role="italic">until</emphasis> the condition is true
(or while the condition is false):
</para>
<screen><![CDATA[# Both of these count from 0 to 10.
print $i++ while $i <= 10;
print $j++ until $j >  10;]]></screen>
<para>
The <literal role="code"><![CDATA[while]]></literal> and <literal
role="code"><![CDATA[until]]></literal> modifiers have the usual "<literal
role="code"><![CDATA[while]]></literal> loop" semantics (conditional
evaluated first), except when applied to a <literal
role="code"><![CDATA[do]]></literal>-BLOCK (or to the deprecated <literal
role="code"><![CDATA[do]]></literal>-SUBROUTINE statement), in which case
the block executes once before the conditional is evaluated.  This is so
that you can write loops like:
</para>
<screen><![CDATA[do {
    $line = <STDIN>;
    ...
} until $line  eq ".\n";]]></screen>
<para>
See <quote>do</quote> in <citerefentry>
<refentrytitle>perlfunc</refentrytitle> </citerefentry>.  Note also that
the loop control statements described later will <emphasis
role="italic">NOT</emphasis> work in this construct, because modifiers
don't take loop labels.  Sorry.  You can always put another block inside of
it (for <literal role="code"><![CDATA[next]]></literal>) or around it (for
<literal role="code"><![CDATA[last]]></literal>) to do that sort of thing.
For <literal role="code"><![CDATA[next]]></literal>, just double the
braces:
</para>
<screen><![CDATA[do {{
    next if $x == $y;
    # do something here
}} until $x++ > $z;]]></screen>
<para>
For <literal role="code"><![CDATA[last]]></literal>, you have to be more
elaborate:
</para>
<screen><![CDATA[LOOP: { 
        do {
            last if $x = $y**2;
            # do something here
        } while $x++ <= $z;
}]]></screen>
<para>
<emphasis role="bold">NOTE:</emphasis> The behaviour of a <literal
role="code"><![CDATA[my]]></literal> statement modified with a statement
modifier conditional or loop construct (e.g. <literal
role="code"><![CDATA[my $x if ...]]></literal>) is <emphasis
role="bold">undefined</emphasis>.  The value of the <literal
role="code"><![CDATA[my]]></literal> variable may be <literal
role="code"><![CDATA[undef]]></literal>, any previously assigned value, or
possibly anything else.  Don't rely on it.  Future versions of perl might
do something different from the version of perl you try it out on.  Here be
dragons.
</para>
</section>
<section id="ID-3f1483781b5788781b4e61230e2baaf5"><title>Compound Statements</title>
<para>
In Perl, a sequence of statements that defines a scope is called a block.
Sometimes a block is delimited by the file containing it (in the case of a
required file, or the program as a whole), and sometimes a block is
delimited by the extent of a string (in the case of an eval).
</para>
<para>
But generally, a block is delimited by curly brackets, also known as
braces. We will call this syntactic construct a BLOCK.
</para>
<para>
The following compound statements may be used to control flow:
</para>
<screen><![CDATA[if (EXPR) BLOCK
if (EXPR) BLOCK else BLOCK
if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
LABEL while (EXPR) BLOCK
LABEL while (EXPR) BLOCK continue BLOCK
LABEL for (EXPR; EXPR; EXPR) BLOCK
LABEL foreach VAR (LIST) BLOCK
LABEL foreach VAR (LIST) BLOCK continue BLOCK
LABEL BLOCK continue BLOCK]]></screen>
<para>
Note that, unlike C and Pascal, these are defined in terms of BLOCKs, not
statements.  This means that the curly brackets are <emphasis
role="italic">required</emphasis>--no dangling statements allowed.  If you
want to write conditionals without curly brackets there are several other
ways to do it.	The following all do the same thing:
</para>
<screen><![CDATA[if (!open(FOO)) { die "Can't open $FOO: $!"; }
die "Can't open $FOO: $!" unless open(FOO);
open(FOO) or die "Can't open $FOO: $!";     # FOO or bust!
open(FOO) ? 'hi mom' : die "Can't open $FOO: $!";
                    # a bit exotic, that last one]]></screen>
<para>
The <literal role="code"><![CDATA[if]]></literal> statement is
straightforward.  Because BLOCKs are always bounded by curly brackets,
there is never any ambiguity about which <literal
role="code"><![CDATA[if]]></literal> an <literal
role="code"><![CDATA[else]]></literal> goes with.  If you use <literal
role="code"><![CDATA[unless]]></literal> in place of <literal
role="code"><![CDATA[if]]></literal>, the sense of the test is reversed.
</para>
<para>
The <literal role="code"><![CDATA[while]]></literal> statement executes the
block as long as the expression is true (does not evaluate to the null
string <literal role="code"><![CDATA[""]]></literal> or <literal
role="code"><![CDATA[0]]></literal> or <literal
role="code"><![CDATA["0"]]></literal>). The LABEL is optional, and if
present, consists of an identifier followed by a colon.  The LABEL
identifies the loop for the loop control statements <literal
role="code"><![CDATA[next]]></literal>, <literal
role="code"><![CDATA[last]]></literal>, and <literal
role="code"><![CDATA[redo]]></literal>. If the LABEL is omitted, the loop
control statement refers to the innermost enclosing loop.  This may include
dynamically looking back your call-stack at run time to find the LABEL. 
Such desperate behavior triggers a warning if you use the <literal
role="code"><![CDATA[use warnings]]></literal> pragma or the <emphasis
role="bold">-w</emphasis> flag.
</para>
<para>
If there is a <literal role="code"><![CDATA[continue]]></literal> BLOCK, it
is always executed just before the conditional is about to be evaluated
again.	Thus it can be used to increment a loop variable, even when the
loop has been continued via the <literal
role="code"><![CDATA[next]]></literal> statement.
</para>
</section>
<section id="ID-fc6beb95015b1bd5ddee3c925c6c711f"><title>Loop Control</title>
<para>
The <literal role="code"><![CDATA[next]]></literal> command starts the next
iteration of the loop:
</para>
<screen><![CDATA[LINE: while (<STDIN>) {
    next LINE if /^#/;      # discard comments
    ...
}]]></screen>
<para>
The <literal role="code"><![CDATA[last]]></literal> command immediately
exits the loop in question.  The <literal
role="code"><![CDATA[continue]]></literal> block, if any, is not executed:
</para>
<screen><![CDATA[LINE: while (<STDIN>) {
    last LINE if /^$/;      # exit when done with header
    ...
}]]></screen>
<para>
The <literal role="code"><![CDATA[redo]]></literal> command restarts the
loop block without evaluating the conditional again.  The <literal
role="code"><![CDATA[continue]]></literal> block, if any, is <emphasis
role="italic">not</emphasis> executed. This command is normally used by
programs that want to lie to themselves about what was just input.
</para>
<para>
For example, when processing a file like <filename>/etc/termcap</filename>.
If your input lines might end in backslashes to indicate continuation, you
want to skip ahead and get the next record.
</para>
<screen><![CDATA[while (<>) {
    chomp;
    if (s/\\$//) {
        $_ .= <>;
        redo unless eof();
    }
    # now process $_
}]]></screen>
<para>
which is Perl short-hand for the more explicitly written version:
</para>
<screen><![CDATA[LINE: while (defined($line = <ARGV>)) {
    chomp($line);
    if ($line =~ s/\\$//) {
        $line .= <ARGV>;
        redo LINE unless eof(); # not eof(ARGV)!
    }
    # now process $line
}]]></screen>
<para>
Note that if there were a <literal
role="code"><![CDATA[continue]]></literal> block on the above code, it
would get executed only on lines discarded by the regex (since redo skips
the continue block). A continue block is often used to reset line counters
or <literal role="code"><![CDATA[?pat?]]></literal> one-time matches:
</para>
<screen><![CDATA[# inspired by :1,$g/fred/s//WILMA/
while (<>) {
    ?(fred)?    && s//WILMA $1 WILMA/;
    ?(barney)?  && s//BETTY $1 BETTY/;
    ?(homer)?   && s//MARGE $1 MARGE/;
} continue {
    print "$ARGV $.: $_";
    close ARGV  if eof();           # reset $.
    reset       if eof();           # reset ?pat?
}]]></screen>
<para>
If the word <literal role="code"><![CDATA[while]]></literal> is replaced by
the word <literal role="code"><![CDATA[until]]></literal>, the sense of the
test is reversed, but the conditional is still tested before the first
iteration.
</para>
<para>
The loop control statements don't work in an <literal
role="code"><![CDATA[if]]></literal> or <literal
role="code"><![CDATA[unless]]></literal>, since they aren't loops.  You can
double the braces to make them such, though.
</para>
<screen><![CDATA[if (/pattern/) {{
    last if /fred/;
    next if /barney/; # same effect as "last", but doesn't document as well
    # do something here
}}]]></screen>
<para>
This is caused by the fact that a block by itself acts as a loop that
executes once, see <link
linkend="ID-fc9a33b5fa16394c9396da9d1454deac"><quote>Basic BLOCKs and
Switch Statements</quote></link>.
</para>
<para>
The form <literal role="code"><![CDATA[while/if BLOCK BLOCK]]></literal>,
available in Perl 4, is no longer available.   Replace any occurrence of
<literal role="code"><![CDATA[if BLOCK]]></literal> by <literal
role="code"><![CDATA[if (do BLOCK)]]></literal>.
</para>
</section>
<section id="ID-666e9c03fde9c96348efe1f3f98c52e9"><title>For Loops</title>
<para>
Perl's C-style <literal role="code"><![CDATA[for]]></literal> loop works
like the corresponding <literal role="code"><![CDATA[while]]></literal>
loop; that means that this:
</para>
<screen><![CDATA[for ($i = 1; $i < 10; $i++) {
    ...
}]]></screen>
<para>
is the same as this:
</para>
<screen><![CDATA[$i = 1;
while ($i < 10) {
    ...
} continue {
    $i++;
}]]></screen>
<para>
There is one minor difference: if variables are declared with <literal
role="code"><![CDATA[my]]></literal> in the initialization section of the
<literal role="code"><![CDATA[for]]></literal>, the lexical scope of those
variables is exactly the <literal role="code"><![CDATA[for]]></literal>
loop (the body of the loop and the control sections).
</para>
<para>
Besides the normal array index looping, <literal
role="code"><![CDATA[for]]></literal> can lend itself to many other
interesting applications.  Here's one that avoids the problem you get into
if you explicitly test for end-of-file on an interactive file descriptor
causing your program to appear to hang.
</para>
<screen><![CDATA[$on_a_tty = -t STDIN && -t STDOUT;
sub prompt { print "yes? " if $on_a_tty }
for ( prompt(); <STDIN>; prompt() ) {
    # do something
}]]></screen>
<para>
Using <literal role="code"><![CDATA[readline]]></literal> (or the operator
form, <literal role="code"><![CDATA[<EXPR>]]></literal>) as the conditional
of a <literal role="code"><![CDATA[for]]></literal> loop is shorthand for
the following.	This behaviour is the same as a <literal
role="code"><![CDATA[while]]></literal> loop conditional.
</para>
<screen><![CDATA[for ( prompt(); defined( $_ = <STDIN> ); prompt() ) {
    # do something
}]]></screen>
</section>
<section id="ID-0ef806f735db950552556bf2cd87a95e"><title>Foreach Loops</title>
<para>
The <literal role="code"><![CDATA[foreach]]></literal> loop iterates over a
normal list value and sets the variable VAR to be each element of the list
in turn.  If the variable is preceded with the keyword <literal
role="code"><![CDATA[my]]></literal>, then it is lexically scoped, and is
therefore visible only within the loop.  Otherwise, the variable is
implicitly local to the loop and regains its former value upon exiting the
loop.  If the variable was previously declared with <literal
role="code"><![CDATA[my]]></literal>, it uses that variable instead of the
global one, but it's still localized to the loop.  This implicit
localisation occurs <emphasis role="italic">only</emphasis> in a <literal
role="code"><![CDATA[foreach]]></literal> loop.
</para>
<para>
The <literal role="code"><![CDATA[foreach]]></literal> keyword is actually
a synonym for the <literal role="code"><![CDATA[for]]></literal> keyword,
so you can use <literal role="code"><![CDATA[foreach]]></literal> for
readability or <literal role="code"><![CDATA[for]]></literal> for brevity. 
(Or because the Bourne shell is more familiar to you than <emphasis
role="italic">csh</emphasis>, so writing <literal
role="code"><![CDATA[for]]></literal> comes more naturally.)  If VAR is
omitted, <literal role="code"><![CDATA[$_]]></literal> is set to each
value.
</para>
<para>
If any element of LIST is an lvalue, you can modify it by modifying VAR
inside the loop.  Conversely, if any element of LIST is NOT an lvalue, any
attempt to modify that element will fail.  In other words, the <literal
role="code"><![CDATA[foreach]]></literal> loop index variable is an
implicit alias for each item in the list that you're looping over.
</para>
<para>
If any part of LIST is an array, <literal
role="code"><![CDATA[foreach]]></literal> will get very confused if you add
or remove elements within the loop body, for example with <literal
role="code"><![CDATA[splice]]></literal>.   So don't do that.
</para>
<para>
<literal role="code"><![CDATA[foreach]]></literal> probably won't do what
you expect if VAR is a tied or other special variable.	 Don't do that
either.
</para>
<para>
Examples:
</para>
<screen><![CDATA[for (@ary) { s/foo/bar/ }

for my $elem (@elements) {
    $elem *= 2;
}

for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {
    print $count, "\n"; sleep(1);
}

for (1..15) { print "Merry Christmas\n"; }

foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
    print "Item: $item\n";
}]]></screen>
<para>
Here's how a C programmer might code up a particular algorithm in Perl:
</para>
<screen><![CDATA[for (my $i = 0; $i < @ary1; $i++) {
    for (my $j = 0; $j < @ary2; $j++) {
        if ($ary1[$i] > $ary2[$j]) {
            last; # can't go to outer :-(
        }
        $ary1[$i] += $ary2[$j];
    }
    # this is where that last takes me
}]]></screen>
<para>
Whereas here's how a Perl programmer more comfortable with the idiom might
do it:
</para>
<screen><![CDATA[OUTER: for my $wid (@ary1) {
INNER:   for my $jet (@ary2) {
            next OUTER if $wid > $jet;
            $wid += $jet;
         }
      }]]></screen>
<para>
See how much easier this is?  It's cleaner, safer, and faster.	It's
cleaner because it's less noisy.  It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed.	The <literal role="code"><![CDATA[next]]></literal>
explicitly iterates the other loop rather than merely terminating the inner
one.  And it's faster because Perl executes a <literal
role="code"><![CDATA[foreach]]></literal> statement more rapidly than it
would the equivalent <literal role="code"><![CDATA[for]]></literal> loop.
</para>
</section>
<section id="ID-fc9a33b5fa16394c9396da9d1454deac"><title>Basic BLOCKs and Switch Statements</title>
<para>
A BLOCK by itself (labeled or not) is semantically equivalent to a loop
that executes once.  Thus you can use any of the loop control statements in
it to leave or restart the block.  (Note that this is <emphasis
role="italic">NOT</emphasis> true in <literal
role="code"><![CDATA[eval{}]]></literal>, <literal
role="code"><![CDATA[sub{}]]></literal>, or contrary to popular belief
<literal role="code"><![CDATA[do{}]]></literal> blocks, which do <emphasis
role="italic">NOT</emphasis> count as loops.)  The <literal
role="code"><![CDATA[continue]]></literal> block is optional.
</para>
<para>
The BLOCK construct is particularly nice for doing case structures.
</para>
<screen><![CDATA[SWITCH: {
    if (/^abc/) { $abc = 1; last SWITCH; }
    if (/^def/) { $def = 1; last SWITCH; }
    if (/^xyz/) { $xyz = 1; last SWITCH; }
    $nothing = 1;
}]]></screen>
<para>
There is no official <literal role="code"><![CDATA[switch]]></literal>
statement in Perl, because there are already several ways to write the
equivalent.
</para>
<para>
However, starting from Perl 5.8 to get switch and case one can use the
Switch extension and say:
</para>
<screen><![CDATA[use Switch;]]></screen>
<para>
after which one has switch and case.  It is not as fast as it could be
because it's not really part of the language (it's done using source
filters) but it is available, and it's very flexible.
</para>
<para>
In addition to the above BLOCK construct, you could write
</para>
<screen><![CDATA[SWITCH: {
    $abc = 1, last SWITCH  if /^abc/;
    $def = 1, last SWITCH  if /^def/;
    $xyz = 1, last SWITCH  if /^xyz/;
    $nothing = 1;
}]]></screen>
<para>
(That's actually not as strange as it looks once you realize that you can
use loop control "operators" within an expression.  That's just the binary
comma operator in scalar context.  See <quote>Comma Operator</quote> in
<citerefentry> <refentrytitle>perlop</refentrytitle> </citerefentry>.)
</para>
<para>
or
</para>
<screen><![CDATA[SWITCH: {
    /^abc/ && do { $abc = 1; last SWITCH; };
    /^def/ && do { $def = 1; last SWITCH; };
    /^xyz/ && do { $xyz = 1; last SWITCH; };
    $nothing = 1;
}]]></screen>
<para>
or formatted so it stands out more as a "proper" <literal
role="code"><![CDATA[switch]]></literal> statement:
</para>
<screen><![CDATA[SWITCH: {
    /^abc/      && do {
                        $abc = 1;
                        last SWITCH;
                   };

/^def/      && do {
                    $def = 1;
                    last SWITCH;
               };

    /^xyz/      && do {
                        $xyz = 1;
                        last SWITCH;
                    };
    $nothing = 1;
}]]></screen>
<para>
or
</para>
<screen><![CDATA[SWITCH: {
    /^abc/ and $abc = 1, last SWITCH;
    /^def/ and $def = 1, last SWITCH;
    /^xyz/ and $xyz = 1, last SWITCH;
    $nothing = 1;
}]]></screen>
<para>
or even, horrors,
</para>
<screen><![CDATA[if (/^abc/)
    { $abc = 1 }
elsif (/^def/)
    { $def = 1 }
elsif (/^xyz/)
    { $xyz = 1 }
else
    { $nothing = 1 }]]></screen>
<para>
A common idiom for a <literal role="code"><![CDATA[switch]]></literal>
statement is to use <literal role="code"><![CDATA[foreach]]></literal>'s
aliasing to make a temporary assignment to <literal
role="code"><![CDATA[$_]]></literal> for convenient matching:
</para>
<screen><![CDATA[SWITCH: for ($where) {
            /In Card Names/     && do { push @flags, '-e'; last; };
            /Anywhere/          && do { push @flags, '-h'; last; };
            /In Rulings/        && do {                    last; };
            die "unknown value for form variable where: `$where'";
        }]]></screen>
<para>
Another interesting approach to a switch statement is arrange for a
<literal role="code"><![CDATA[do]]></literal> block to return the proper
value:
</para>
<screen><![CDATA[$amode = do {
    if     ($flag & O_RDONLY) { "r" }       # XXX: isn't this 0?
    elsif  ($flag & O_WRONLY) { ($flag & O_APPEND) ? "a" : "w" }
    elsif  ($flag & O_RDWR)   {
        if ($flag & O_CREAT)  { "w+" }
        else                  { ($flag & O_APPEND) ? "a+" : "r+" }
    }
};]]></screen>
<para>
Or
</para>
<screen><![CDATA[print do {
    ($flags & O_WRONLY) ? "write-only"          :
    ($flags & O_RDWR)   ? "read-write"          :
                          "read-only";
};]]></screen>
<para>
Or if you are certain that all the <literal
role="code"><![CDATA[&&]]></literal> clauses are true, you can use
something like this, which "switches" on the value of the <literal
role="code"><![CDATA[HTTP_USER_AGENT]]></literal> environment variable.
</para>
<screen><![CDATA[#!/usr/bin/perl 
# pick out jargon file page based on browser
$dir = 'http://www.wins.uva.nl/~mes/jargon';
for ($ENV{HTTP_USER_AGENT}) { 
    $page  =    /Mac/            && 'm/Macintrash.html'
             || /Win(dows )?NT/  && 'e/evilandrude.html'
             || /Win|MSIE|WebTV/ && 'm/MicroslothWindows.html'
             || /Linux/          && 'l/Linux.html'
             || /HP-UX/          && 'h/HP-SUX.html'
             || /SunOS/          && 's/ScumOS.html'
             ||                     'a/AppendixB.html';
}
print "Location: $dir/$page\015\012\015\012";]]></screen>
<para>
That kind of switch statement only works when you know the <literal
role="code"><![CDATA[&&]]></literal> clauses will be true.  If you don't,
the previous <literal role="code"><![CDATA[?:]]></literal> example should
be used.
</para>
<para>
You might also consider writing a hash of subroutine references instead of
synthesizing a <literal role="code"><![CDATA[switch]]></literal> statement.
</para>
</section>
<section id="ID-65e5bc29ddd4d302e4c68019af3eb62c"><title>Goto</title>
<para>
Although not for the faint of heart, Perl does support a <literal
role="code"><![CDATA[goto]]></literal> statement.  There are three forms:
<literal role="code"><![CDATA[goto]]></literal>-LABEL, <literal
role="code"><![CDATA[goto]]></literal>-EXPR, and <literal
role="code"><![CDATA[goto]]></literal>-&amp;NAME.  A loop's LABEL is not
actually a valid target for a <literal
role="code"><![CDATA[goto]]></literal>; it's just the name of the loop.
</para>
<para>
The <literal role="code"><![CDATA[goto]]></literal>-LABEL form finds the
statement labeled with LABEL and resumes execution there.  It may not be
used to go into any construct that requires initialization, such as a
subroutine or a <literal role="code"><![CDATA[foreach]]></literal> loop. 
It also can't be used to go into a construct that is optimized away.  It
can be used to go almost anywhere else within the dynamic scope, including
out of subroutines, but it's usually better to use some other construct
such as <literal role="code"><![CDATA[last]]></literal> or <literal
role="code"><![CDATA[die]]></literal>.	The author of Perl has never felt
the need to use this form of <literal
role="code"><![CDATA[goto]]></literal> (in Perl, that is--C is another
matter).
</para>
<para>
The <literal role="code"><![CDATA[goto]]></literal>-EXPR form expects a
label name, whose scope will be resolved dynamically.  This allows for
computed <literal role="code"><![CDATA[goto]]></literal>s per FORTRAN, but
isn't necessarily recommended if you're optimizing for maintainability:
</para>
<screen><![CDATA[goto(("FOO", "BAR", "GLARCH")[$i]);]]></screen>
<para>
The <literal role="code"><![CDATA[goto]]></literal>-&amp;NAME form is
highly magical, and substitutes a call to the named subroutine for the
currently running subroutine.  This is used by <literal
role="code"><![CDATA[AUTOLOAD()]]></literal> subroutines that wish to load
another subroutine and then pretend that the other subroutine had been
called in the first place (except that any modifications to <literal
role="code"><![CDATA[@_]]></literal> in the current subroutine are
propagated to the other subroutine.)  After the <literal
role="code"><![CDATA[goto]]></literal>, not even <literal
role="code"><![CDATA[caller()]]></literal> will be able to tell that this
routine was called first.
</para>
<para>
In almost all cases like this, it's usually a far, far better idea to use
the structured control flow mechanisms of <literal
role="code"><![CDATA[next]]></literal>, <literal
role="code"><![CDATA[last]]></literal>, or <literal
role="code"><![CDATA[redo]]></literal> instead of resorting to a <literal
role="code"><![CDATA[goto]]></literal>.  For certain applications, the
catch and throw pair of <literal role="code"><![CDATA[eval{}]]></literal>
and die() for exception processing can also be a prudent approach.
</para>
</section>
<section id="ID-a287837f130d1a1e3f8c1acd468739a1"><title>PODs: Embedded Documentation</title>
<para>
Perl has a mechanism for intermixing documentation with source code. While
it's expecting the beginning of a new statement, if the compiler encounters
a line that begins with an equal sign and a word, like this
</para>
<screen><![CDATA[=head1 Here There Be Pods!]]></screen>
<para>
Then that text and all remaining text up through and including a line
beginning with <literal role="code"><![CDATA[=cut]]></literal> will be
ignored.  The format of the intervening text is described in <citerefentry>
<refentrytitle>perlpod</refentrytitle> </citerefentry>.
</para>
<para>
This allows you to intermix your source code and your documentation text
freely, as in
</para>
<screen><![CDATA[=item snazzle($)

The snazzle() function will behave in the most spectacular
form that you can possibly imagine, not even excepting
cybernetic pyrotechnics.

=cut back to the compiler, nuff of this pod stuff!

sub snazzle($) {
    my $thingie = shift;
    .........
}]]></screen>
<para>
Note that pod translators should look at only paragraphs beginning with a
pod directive (it makes parsing easier), whereas the compiler actually
knows to look for pod escapes even in the middle of a paragraph.  This
means that the following secret stuff will be ignored by both the compiler
and the translators.
</para>
<screen><![CDATA[$a=3;
=secret stuff
 warn "Neither POD nor CODE!?"
=cut back
print "got $a\n";]]></screen>
<para>
You probably shouldn't rely upon the <literal
role="code"><![CDATA[warn()]]></literal> being podded out forever. Not all
pod translators are well-behaved in this regard, and perhaps the compiler
will become pickier.
</para>
<para>
One may also use pod directives to quickly comment out a section of code.
</para>
</section>
<section id="ID-820f14517027c470638e08306b1d4e4f"><title>Plain Old Comments (Not!)</title>
<para>
Perl can process line directives, much like the C preprocessor.  Using
this, one can control Perl's idea of filenames and line numbers in error or
warning messages (especially for strings that are processed with <literal
role="code"><![CDATA[eval()]]></literal>).  The syntax for this mechanism
is the same as for most C preprocessors: it matches the regular expression
</para>
<screen><![CDATA[# example: '# line 42 "new_filename.plx"'
/^\#   \s*
  line \s+ (\d+)   \s*
  (?:\s("?)([^"]+)\2)? \s*
 $/x]]></screen>
<para>
with <literal role="code"><![CDATA[$1]]></literal> being the line number
for the next line, and <literal role="code"><![CDATA[$3]]></literal> being
the optional filename (specified with or without quotes).
</para>
<para>
There is a fairly obvious gotcha included with the line directive:
Debuggers and profilers will only show the last source line to appear at a
particular line number in a given file.  Care should be taken not to cause
line number collisions in code you'd like to debug later.
</para>
<para>
Here are some examples that you should be able to type into your command
shell:
</para>
<screen><![CDATA[% perl
# line 200 "bzzzt"
# the `#' on the previous line must be the first char on line
die 'foo';
__END__
foo at bzzzt line 201.

% perl
# line 200 "bzzzt"
eval qq[\n#line 2001 ""\ndie 'foo']; print $@;
__END__
foo at - line 2001.

% perl
eval qq[\n#line 200 "foo bar"\ndie 'foo']; print $@;
__END__
foo at foo bar line 200.

% perl
# line 345 "goop"
eval "\n#line " . __LINE__ . ' "' . __FILE__ ."\"\ndie 'foo'";
print $@;
__END__
foo at goop line 345.]]></screen>
</section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-parent-document: "fcs_arch_doc.xml"
End:
vim:indentexpr=:
-->
